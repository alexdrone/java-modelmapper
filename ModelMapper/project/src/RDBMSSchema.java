// 
//  RDBMSSchema
//  ModelMapper
//  
//  Created by Querella Luca and Usbergo Alex on 2010-01-31.
//  Universit√† di Torino 
//

package modelmapper;

import modelmapper.schema.*;

import modelmapper.exception.*;
import modelmapper.annotation.*;

import java.util.*;
import java.lang.reflect.*;

/**
 * This class contains all the information of the {@link Model} 
 * interfaces relational
 * translation. It's used by the entire <code>RDBMS</code> Factory for 
 * retrieve useful 
 * informations for navigate through table references.
 *
 * @author Alex Usbergo, Luca Querella
 */
public class RDBMSSchema {
	
	private Map<Class, List<Attribute>> 
		attributes = new HashMap<Class, List<Attribute>>();
	
	private Map<Class, List<Class>> 
		klass =  new HashMap<Class, List<Class>>();
	
	private Map<String, Relationship> 
		relationships = new HashMap<String, Relationship>();
	
	private List<Class> builded  = new ArrayList<Class>();
	private List<Class> analyzed = new ArrayList<Class>();
	private List<Class> created  = new ArrayList<Class>();
	
	private RDBMSModelFactory factory;
	private RDBMSSchemaGenerator generator;
	private String schema = "";

	public RDBMSSchema(RDBMSModelFactory factory) { 
		this.factory = factory; 
		this.generator = factory.getSchemaGenerator();
	}
	
	/**
	 * Initialize all the maps that contains the relational structure for a 
	 * given model interface <code>type</code>.
	 * It calls <code>createSchema</code> for the attribute mapping and 
	 * <code>getRelationships</code>
	 * for generating the map of {@link Relationship} used by the whole 
	 * {@link RDBMSModelFactory} for navigate through references.
	 * @param type The given model interface.
	 */
	public void migrate(Class... models) { 
		for (Class m : models) initSchema(m); 
	}
	
	public void initSchema(Class type) {
		
		if (analyzed.contains(type)) return;
		
		List<Class> supers = factory.getCache().getAllSupers(type);
		supers.add(type);
		
		Set<Class> back = new HashSet<Class>();
		
		for (Class s : supers) analyzeClass(s, back);
			
		Class[] build = 
			back.toArray((Class[]) 
			java.lang.reflect.Array.newInstance(Class.class, back.size()));	
			
		createSchema(build);
		
		for (Class b : build) getRelationships(b);

		analyzed.add(type);
	}
	
	
	/**
	 * This class generates the <code>DDL</code> for the schema creation of 
	 * the given classes. 
	 * At the moment it doesn't support the <em>Migration</em> mechanism, but 
	 * will been soon implemented.
	 * However is a good start point for a new project.
	 * <p>It's important to know that this class just create the relational 
	 * structure of the translation (using the {@link Attribute} class), and 
	 * it doesn't write a single SQL line.
	 * The <code>CREATE TABLE</code> statements are generated by a provided 
	 * {@link SchemaGenerator}.
	 * <p>The tables will be created with the following conventions: <ul>
	 * <li> A table for every class. The field annotated with 
	 * {@link modelmapper.annotation.Id} will be marked as 
	 * <code>PRIMARY KEY</code> in the database schema.
	 * Other annotations such as {@link modelmapper.annotation.Unique} or 
	 * {@link modelmapper.annotation.NotNull} are parsed and translated in 
	 * relational costraints.</li>
	 * <li> Multiple and single inheritance are handled with separate tables 
	 * and foreign keys due to maintain the polymorphism in the database 
	 * structure.
	 * When a model inherits from <strong>multiple</strong> models, it always 
	 * has to define an Id.
	 * <li> In thhe <strong>single</strong> inheritance between two table, 
	 * let's call them B < A, if B defines an Id it will be his primary key 
	 * and it will have an attribute
	 * called <code>A.(AIdName)</code>. Instead if no Id is defined for B, 
	 * it will inherit the one from A.</li>
	 * <li> The attribute set of classes the takes part in a multiple 
	 * inheritance must be <code>disjoint</code>. 
	 * (All this costraints are verified by {@link modelmapper.Validator}
	 * class).</li>
	 * <li> A join table named as the 
	 * {@link modelmapper.annotation.Connection} is created for every 
	 * <code>ManyToMany</code> relationship.</li></ul></p>
	 * @param interfaces The given model interfaces.
	 * @return The string containing the DDL statementes for creating the 
	 * database schema.
	 */
	public String createSchema(Class... interfaces) {
		
		/* init attributes */
		for (Class i : interfaces) {
			
			if (created.contains(i)) return "";
			else created.add(i);
			
			Method[] getters = CommonStatic.getGetters(i);
			List<Attribute> interfaceAttributes = new ArrayList<Attribute>();
			
			for (Method m : getters) {

				Attribute a = new Attribute(factory.getCache().fieldName(m));
				a.type = m.getReturnType();
				
				/* field options */
				a.isId = m.isAnnotationPresent(Id.class);
				a.isAutoIncrement = m.isAnnotationPresent(AutoIncrement.class);
				a.isNotNull = m.isAnnotationPresent(NotNull.class);
				a.isUnique = m.isAnnotationPresent(Unique.class);
				
				if (!m.isAnnotationPresent(Connection.class))
					a.sqlType = generator.getDefaultMappedType(a.type);
				
				/* if is a field with a foreign keys to his owner */
				else if (m.getAnnotation(Connection.class).type().
						 equals(ConnectionType.BelongsTo)) {
					
					Connection c = m.getAnnotation(Connection.class);
					Class owner = m.getReturnType();
					
					boolean composition = false;
					
					/* search if the owner of this relationship declared a 
					   composition or an aggregation */
					Method[] ownerMethods = owner.getMethods();
					for (Method o : ownerMethods)
						if (o.isAnnotationPresent(Connection.class)) {
							
							/* Is a Composition? */
							Connection oC = o.getAnnotation(Connection.class);
							if (oC.name().equals(c.name()) &&
							 	oC.type().equals(ConnectionType.Composition))
								composition = true;
						}
							
					/* The field type is the same of the owner table Id */
					a.sqlType = generator.getDefaultMappedType(
								factory.getCache().getModelIdType(owner));
					
					/* Add the foreign key to this attribute */
					a.isAForeignKey = true;
					a.composition = composition;
					a.foreignTable = factory.getCache().tableName(owner);
					a.foreignTableId = factory.getCache().getModelId(owner);
				}
				
				if(!m.isAnnotationPresent(Connection.class) || a.isAForeignKey)
					interfaceAttributes.add(a);
			}
				
			/* created at */
			Attribute createdAt = new Attribute("CreatedAt");
			createdAt.type = java.sql.Timestamp.class;
			createdAt.sqlType = generator.getDefaultMappedType(createdAt.type);
			
			/* updated at */
			Attribute updatedAt = new Attribute("UpdatedAt");
			updatedAt.type = java.sql.Timestamp.class;
			updatedAt.sqlType = generator.getDefaultMappedType(updatedAt.type);
			
			interfaceAttributes.add(createdAt);
			interfaceAttributes.add(updatedAt);
			
			attributes.put(i, interfaceAttributes);
		}
		
		/* Checks for foreign inherited keys */
		for (Class i : interfaces) {
				
			/* If the model extends other models, their primary keys are 
			 * inserted into his table, with a foreign key costraint */
				
			List<Class> extended = CommonStatic.getSupers(i);
			for (Class e : extended) {
				Attribute a = new Attribute(factory.getCache().tableName(e) + 
											factory.getCache().getModelId(e));
					
				a.type = e;
				a.sqlType = generator.getDefaultMappedType(
							factory.getCache().getModelIdType(e));	
											
				a.isId = true;
				a.isAForeignKey = true;
				a.isNotNull = true;
				a.composition = true;
				a.foreignTable = factory.getCache().tableName(e);
				a.foreignTableId = factory.getCache().getModelId(e);
				
				attributes.get(i).add(a);
			}
			
			/* Generate the schema */
			schema += generator.createDDL(	
					  factory.getCache().tableName(i), attributes.get(i), 
					  factory.getCache().getModelId(i)) + "\n";		 
		}	
		
		for (Class i : interfaces) {
		
			/* Generate the constraints */
			schema += generator.createConstraints(	
					  factory.getCache().tableName(i), attributes.get(i), 
					  factory.getCache().getModelId(i)) + "\n";
		}
				
		/* Loads all the connection informations */
		for (Class i : interfaces) getRelationships(i);
		
		for (String r : relationships.keySet()) 
			schema += generator.createJoinTable(relationships.get(r));
			
		return schema;
	}
	
	/**
	 * Returns the <code>CREATE</code> statement used for build 
	 * the model tables
	 * @return The DDL executed for the table creation
	 */
	public String toString() { return schema; }
	
	private void analyzeClass(Class type, Set<Class> build) {		
		
		if (build.contains(type)) return;
		
		
		build.add(type);
		List<Class> classes = factory.getCache().getAllReleatedClasses(type);
		
		for (Class c : classes) analyzeClass(c, build);
	}
	
	public Relationship getNamedRelationship(String name) { 
		return relationships.get(name); 
	}
	
	/**
	 * Search all the {@link modelmapper.annotation.Connection} annotations in 
	 * the given class and recreate a map with the relational references 
	 * structure.
	 * @param model The {@link modelmapper.Model} interface.
	 */
	private void getRelationships(Class model) {
				
		/* the class have been already analyzed */
		if (builded.contains(model)) return;
		else builded.add(model);
				
		List<Method> connectionGetters = new ArrayList<Method>();
		Method[] all = model.getDeclaredMethods();
		
		for (Method m : all) 
			/* Search all the connection getters */
			if(m.isAnnotationPresent(Connection.class)) {
				Connection c = m.getAnnotation(Connection.class);
				Relationship rship = new Relationship(c.name(), c.type());
								
				/* Case Many To Many or Belongs To */
				if (c.type().equals(ConnectionType.ManyToMany) || 
					c.type().equals(ConnectionType.BelongsTo)) {
					
					/* The symmetric part of the relationship has already 
					   been found */
					if (relationships.containsKey(c.name())) {
						relationships.get(c.name()).tableB = 
							factory.getCache().tableName(model);
							
						relationships.get(c.name()).fieldB = 
							factory.getCache().fieldName(m);
							
						relationships.get(c.name()).classB = model;
						
					} else {
						if (CommonStatic.isRecursive(model, c.name())) {
							rship.classB = rship.classA = model;
							
							rship.tableB = rship.tableA = 
								factory.getCache().tableName(model);
								
							rship.fieldB = factory.getCache().fieldName(m);
							rship.fieldA = rship.tableA + 
										   factory.getCache().getModelId(model);
						
						} else if(c.type().equals(ConnectionType.ManyToMany)){
							rship.tableA = factory.getCache().tableName(model);
							rship.fieldA = factory.getCache().fieldName(m);
							rship.classA = model;
						
						} else { /* Belongs To case */
							rship.tableB = factory.getCache().tableName(model);
							rship.fieldB = factory.getCache().fieldName(m);
							rship.classB = model;
						}
						/* Add the relationship */
						relationships.put(c.name(), rship);
					}
				} 
				
				/* Case Aggregation/Composition */
				if (c.type().equals(ConnectionType.Aggregation) || 
					c.type().equals(ConnectionType.Composition)) {
					
					/* The symmetric part of the relationship has already been 
					   found */
					if (relationships.containsKey(c.name())) {
						relationships.get(c.name()).tableA = 
							factory.getCache().tableName(model);
							
						relationships.get(c.name()).fieldA = 
							factory.getCache().fieldName(m);
							
						relationships.get(c.name()).classA = model;
						relationships.get(c.name()).type = c.type();
						
					} else {
						rship.tableA = factory.getCache().tableName(model);
						rship.fieldA = factory.getCache().fieldName(m);
						rship.classA = model;						
						
						/* Add the relationship */
						relationships.put(c.name(), rship);
					}
					
				} 
			}
	}
	

} 
